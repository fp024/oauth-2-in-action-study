# 1장. OAuth 2.0이 무엇이고, 왜 관심을 가져야할까?

* OAuth: 웹 API를 보호하기 위해 사용되는 보안 프로토콜

  * 웹사이트들을 다른 사이트에 연결
  * 네이티브/모바일 어플리케이션을 클라우드 서비스에 연결 등등..

  

## 1.1 OAuth 2.0은 무엇인가?

* 웹을 위한 "발렛 키"

  * 발렛키가 뭔말인가 했는데.. 차를 발렛해주는 직원한태 맞길 때, 자동차를 조작할 수 있는 권한이 제한된 키를 준다는 말인 것 같다.

  * OAuth 스팩에서의 정의 문구

    > * HTTP 서비스와 리소스에 대한 접근요청 승인을 조정
    > * 서드파티 어플리케이션에게 리소스에 대한 접근을 허용해주는 방식으로 HTTP 서비스에 대한 서드파티 어플리케이션의 접근을 가능하게 해줌.



#### OAuth의 구성요소

* 리소스 소유자
  * 서비스 사용자
* 보호된 리소스
  * 대부분의 경우 웹 API 형태
    * 웹 API로도 Read/Write가 가능함.
* 클라이언트
  * 보호된 리소스를 구성하는 API를 이용하는 소프트웨어



## 1.2 과거: 자격 증명 공유 (그리고 자격 증명 탈취)

#### 사용자의 자격증명을 복사해 연결하고자 하는 다른 서비스에 전달

#### 클라이언트와 보호된 리소스가 하나의 보안 도메인에 있을 경우

* 사용자의 비밀번호가 클라이언트에게 노출됨
* 보호된 리소스 입장에서 접근자가 사용자인지? 클라이언트인지 구분할 수 없음.



#### 클라이언트와 보호된 리소스가 다른 보안 도메인에 있을 경우

* 보호된 리소스 접근시 사용자에게 비밀번호를 물어봄

* 클라이언트가 자격증명을 저장하여 필요할 때 다시 사용 (위험🎃)

  * 그런데..LDAP 인증을 사용한다면 클라이언트가 평문 암호를 전달할 수 밖에 없다고 함..

  

#### 개발자 키를 클라이언트에 발급하고 클라이언트는 그것을 이용해 보호된 리소스에 접근

* 사용자의 자격증명이 클라이언트에 노출되지 않는 장점.
* 그런데 이 개발자 키가 보호된 리소스의 모든 자료에 접근이 가능하다면 역시 문제가 있음..😓



#### 서드 파티 서비스(클라이언트)에만 공유할 목적으로 사용되는 특별한 비밀번호를 사용자에게 발급

* 제한된 발렛 키와 비슷





## 1.3 접근권한 위임

* OAuth는 보호된 리소스에 접근하기 위한 사용자의 접근권한 일부를 클라이언트에 위임하기 위해 설계된 프로토콜.
  * 이것을 위해 OAuth에는 `인가 서버`라는 구성요소가 추가됨

클라이언트가 토큰을 요청, 사용자는 해당 클라이언트를 인가하는 방식으로 클라이언트에 접근권한을 부여.



### 1.3.1 HTTP Basic과 비밀번호 공유 방식을 넘어...



### 1.3.2 권한 위임: 중요성과 사용방법



### 1.3.3 사용자 주도 보안과 사용자 선택

* 중요한 보안 결정이 최종 사용자의 선택에 의해 결정됨
* TOFU<sup>Trust On First Use</sup>: 
  * 보안적인 결정이 런타임에 사용자에게 요구됨.
  * 처음으로 권한 인가가 이루어지면 이후의 처리를 위해 시스템이 사용자의 결정을 신뢰하도록 만들 수 있음.
  * 처음 사용한다고 결정했으면 이 결정을 신뢰하고 이후에 묻지 않는다는 말 같음.
    * Windows Vista의 UAC가 거의 모든 내용에 대해 관리자 권한으로 실행할지 묻는 식이였던 것 같은데.. Windows 7부터 중요도가 높지 않는 내용에 대해서는 알림을 많이 줄인 것 같았다.




## 1.4 OAuth 2.0: 좋은 점과 나쁜 점

* 인가서버나 보호된 리소스 서버보다 항상 몇 배나 더많은 클라이언트가 있을 것으로 가정함.

* 인가서버에서 클라이언트를 여러가지 신뢰 레벨로분류 할 수 있음

  

  

##### 장점

* 복잡성이 서버측에 있어 클라이언트는 단순해질 수 있음.
* 클라이언트가 침해당하더라도 그 피해는 그 클라이언트로 제한됨
* 자격증명을 인가 서버에서 관리하게되어, 수많은 클라이언트를 관리하는 것보다 더 나음
* 확장성과 모듈화로 다양한 환경에서도 사용할 수 있음.

##### 단점

* OAuth의 에서 많은 부분을 선택사항으로 기술하여 OAuth구현체 간의 기본적인 호환성 문제 발생가능

* 잘못이해할 경우 안전하지 않은 OAuth구현을 만들 수도 있음.

  



## 1.5 OAuth 2.0이 아닌 것

OAuth 인 것

* 엑세스 토큰을 얻기 위한 몇가지 방법을 자세히 설명하는 핵심 OAuth 스팩에 정의된 프로토콜
  * RFC 6749 (https://datatracker.ietf.org/doc/html/rfc6749) 

* Bearer 토큰의 사용방법을 기술한 부가적인 스팩
  * RFC 6750 ( https://datatracker.ietf.org/doc/html/rfc6750 )



**OAuth는 HTTP 프로토콜과 독립적으로 정의되지 않음**

> OAuth 2.0 Bearer 토콘은 메시지 시그니처를 제공하지 않아 HTTS를 이용해야함.



**OAuth는 인증 프로토콜이 아니다.**

> OAuth 트랜잭션 자체만으로는 사용자가 누구인지 알 수 없음.
>
> 예) 사진 인화 서비스에서는 사용자가 누구인지는 알필요가 없고 누군가 자신의 사진을 다운로드할 수 있도록 허락해줬다는 것이 중요.



**사용자 간의 권한 위침 메커니즘은 정의하지 않는다.**



**OAuth는 인가 절차 메커니즘을 정의하지 않는다.**



**OAuth는 토큰의 포맷을 정의하지 않는다.**



**OAuth 2.0dms OAuth 1.0과 달리 암호화 방법을 정의하지 않는다.**



**OAuth 2.0은 또한 단일 프로토콜이 아니다.**





## 1.6 요약

OAuth 란...

* 토큰을 어떻게 획득하고 그것을 어떻게 사용하는 지에 대한 스팩
* 인가 접근 시스템을 위한 권한 위임 프로토콜
* 비밀번호 공유 패턴을 대체함
* 작은 문제를 잘 해결하는 것에 초점을 맞춤.



## 의견

뒷부분이 뭔가 어렵다.. 그래도 계속 진행하다보면 알 것 같다.





## 단어

* [인가](https://ko.dict.naver.com/#/entry/koko/dd3b26a81f8843d3a077979a6a1fef18) (認可)
  * 인정하여 허가함.

* [위임](https://ko.dict.naver.com/#/entry/koko/3e22dc6e397a418884818349a3d7c459) (委任)
  * 어떤 일을 책임 지워 맡김. 또는 그 책임.



## 정오표

* p38. 그림 바로아래 3줄의 내용이 이미 앞장에 있음.. 제거하면 될 듯.
