# 3장. 간단한 OAuth 클라이언트



> 그런데.. `인가 코드 그랜트 타입` 이게 뭐지? 
>
> * p60의 방식 자체를 말하는 것 같다. 책의 그림 2.1 `인가 코드 그랜트` 항목을 보도록 하자!
> * Part 2 OAuth 2 환경 구축에서는 인가 코드 그랜트 타입 자체를 구현한다는 것 같다.
> * 예제 수정전에는 한번 prettier 돌리고 시작하자!





## 3.1 인가 서버에 OAuth 클라이언트 등록

* ch-3-ex-1 프로젝트의 client.js 수정.



## 3.2 인가 코드 그랜트 타입을 이용해 토큰 얻기

### 3.2.1 인가 요청 보내기



### 3.2.2 인가 요청에 대한 응답 처리

* 관련 커밋
  * https://github.com/fp024/oauth-in-action-code/commit/a885e87ff9e342e298c8e0a8af7de8e99999a39f



### 3.2.3 크로스 사이트 공격을 방지하기 위한 state 파라미터 추가

* 관련 커밋
  * https://github.com/fp024/oauth-in-action-code/commit/dcc83ca782ca67203a3c73fe4799fa402ea304be





## 3.3 보호된 리소스에 접근하기 위한 토큰 사용

* 클라이언트는 액세스 토큰을 이용해 보호된 리소스를 요청
* OAuth 스팩에서 권장하는 방법은...
  * Authorization HTTP 헤더에 액세스 토큰을 담아 전달



#### Bearer 토큰을 전달하는방법

* HTTP Authorization 헤더를 이용하는 방법 (✨ 권장하는방법)
  * 일부 클라이언트에서 사용하지 못할 수 있지만 가장 큰 유연성과 보안성 제공
* 폼 인코딩된 요청 파라미터로 전달하는 방법 
  * POST 전송만 사용가능
* URL 인코딩된 질의 파라미터로 전달하는 방법
  * URL에 노출되므로 실수로 서버의 로그에 엑세스 토큰 값이 놀출될 수 있음.



* 관련 커밋
  * https://github.com/fp024/oauth-in-action-code/commit/997bdd66cabf4474dd6aa5deac2d6003d957bc9b



#### 추가 연습 과제

* [x] 요청이 실패 했을 때... 자동으로 사용자에게 클라이언트를 인가해달라는 요청을 하도록 수정해볼 것!

  * 단순하게 관련 부분에 클라이언트의 `/authorize`로 리다이렉트하는 코드를 넣었다.

    ```javascript
    res.redirect("/authorize");
    ```

    

  * 관련 커밋

    * https://github.com/fp024/oauth-in-action-code/commit/5dcab8b82c0ed0d0138824870f92992c4214fad7





## 3.4 액세스 토큰 갱신

OAuth에서는 액세스 토큰이 만료되는 경우...

`리프레시 토큰을` 이용하여 사용자의 개입없이도 새로운 액세스 토큰을 얻을 수 있는 방법을 제공함.

* 새로운 프로젝트
  * **ch-3-ex-2**
  
  * 유효하지 않은 토큰 동작을 확인하려면 바로 `Get Protected Resource` 버튼을 눌러 확인하면 된다.
  
    



#### 지금 갖고 있는 토큰이 유효한 것일까?

* 일단 사용해보고 무슨일이 발생하는지 확인하는 것임.
* 인가서버는 expires_in 선택적 필드를 사용해 토큰의 예상 만료 시간에 대한 힌트를 제공해줌.



* 관련 커밋
  * https://github.com/fp024/oauth-in-action-code/commit/d5115383d8fb096ea138f433cf7346508d0f6e8c
  * https://github.com/fp024/oauth-in-action-code/commit/406120c7caa564647d7d538fc0d34709a97c62e9
  * https://github.com/fp024/oauth-in-action-code/commit/e8a3666b5f9ec3da5987bba22172323c37ba1d30



**참고:**

* 리프레시 토큰을 통해 엑세스 토큰을 성공적으로 받은 상태라면... 다시 테스트를 하려면 client.js를 다시 재시작해야한다. client.js 프로세스에 올바른 토큰이 들어간 상태여서, 브라우저를 새로고침 하면 되는 것은 아닌지라고 착각하면 안됨..😓
* 리프레시 토큰을 인가 서버에서 알고있다. 예제에서는 인가서버 실행시점에 해당 클라이언트 ID에 대한 리프레시토큰을 자동으로 초기화해주는 부분이 있다.
* 엑세스 토큰이 실패했다고 그냥 끝내면 안됨.  이때는 엑세스토큰이 없는 상태가 되므로 사용자에게 클라이언트를 다시 인가해달라고 요청할 수 있음.



## 요약

* ...
* 클라이언트가 리프레시 토큰을 사용할 수 있다면, 클라이언트는 사용자 개입없이 리프레시 토큰으로 새로운 토큰을 얻을 수 있음.
* OAuth 2.0 Bearer 토큰을 이용하는 것은 매우 간단함. HTTP 요청을 할 때마다 간단한 HTTP 헤더(Authorization 헤더)만 추가하면 됨



## 의견

* Node, Express를 잘 몰라도 어느정도 따라 갈 수 있을 것 같다.
* 중요한 부분만 빈 메서드로 만들어주셔서 문제 답 채우듯이 진행했다. 😄 괜찮은 것 같음.



## 정오표

* ...
